(window.webpackJsonp=window.webpackJsonp||[]).push([[146],{579:function(t,s,a){"use strict";a.r(s);var n=a(2),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("在上一讲中，我用鸡生蛋，然后人们吃荷包蛋的例子介绍了 Go 并发通道（Channel）中的同步通道。同步通道又被称为无缓冲的通道，它要求数据的发送者和接收者必须配对存在。在实际开发中，我们会用到同步通道，也会用到带缓冲的通道。")]),t._v(" "),s("p",[t._v("和同步通道不同，带缓冲的通道有点类似于快递员（协程 A）和收件人（协程 B）的关系，在他们之间存在一个快递驿站（缓冲区）。寄送快递时，快递员会默认将快递放到驿站中，收件人可以找个合适的时间去驿站中取快递。当驿站放满快递时，新的快递便无法存入其中，必须等待旧的快递被取走。这个过程描述的便是带缓冲的通道的工作流程。")]),t._v(" "),s("p",[t._v("本讲我将会向大家介绍缓冲通道，以及如何构建更安全的通道。")]),t._v(" "),s("h2",{attrs:{id:"缓冲通道"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓冲通道"}},[t._v("#")]),t._v(" 缓冲通道")]),t._v(" "),s("p",[t._v("还记得上一讲中的示例吧，为了方便大家回忆，我把完整的示例代码拿了过来：")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("go")]),t._v("\n复制代码"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" syncWait sync"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("WaitGroup\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 创建通道类型变量，该通道将传送int类型数据")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" intChan "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("make")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("chan")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 执行2个协程任务")]),t._v("\n   syncWait"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 开启下蛋任务")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("go")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("layEggs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 开启吃荷包蛋任务")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("go")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("eatEggs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("intChan"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 等待协程任务完成")]),t._v("\n   syncWait"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Wait")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("layEggs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用断言确保协程任务正常结束")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("defer")]),t._v(" syncWait"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Done")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 向通道传送int类型值")]),t._v("\n   intChan "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 关闭通道")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("close")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("intChan"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("eatEggs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("intChan "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("chan")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用断言确保协程任务正常结束")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("defer")]),t._v(" syncWait"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Done")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 从通道获取int类型值")]),t._v("\n   eggCounts "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<-")]),t._v("intChan\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 输出结果")]),t._v("\n   fmt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Printf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"吃%d个荷包蛋"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" eggCounts"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("在这段代码中，intChan 就是构建的同步通道，通道内允许传送的数据类型是 int 型。main() 函数中开启了两个协程任务，分别是 layEggs() （产蛋）和 eatEggs() （吃蛋）。前者将会向同步通道中传出 1，表示产出 1 个蛋；后者从同步通道中读取值， 结果为 1，表示拿出 1 个蛋来吃。")]),t._v(" "),s("p",[t._v("在现实生活中，如果要统计一只鸡一周能产多少个鸡蛋，用上述同步方法就不是特别合适了。我们通常会用一个容器来存放这只鸡每天产下的鸡蛋，然后在 7 天后数容器内的鸡蛋的数量，便可得知这只鸡在这周产下的鸡蛋总数了。这里的“容器”其实就是缓冲通道中的缓冲区了。")]),t._v(" "),s("p",[t._v("若要实现这种统计并非难事，只需将上述代码稍加修改即可。")]),t._v(" "),s("p",[t._v("首要任务就是修改通道的创建模式，根据示例要求，需要统计 7 天的产蛋总量，我们便可将缓冲区的容量定为7。具体代码修改如下：")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("go")]),t._v("\n复制代码"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" DaysOfWeek "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" intChan "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("make")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("chan")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" DaysOfWeek"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("这里声明了一个常量，表示一周的天数，同时也规定了 intChan 通道的缓冲区大小就是 7。考虑到稍后在发送和接收时都需要用到缓冲区大小值，所以将该常量声明为全局可访问的。")]),t._v(" "),s("p",[t._v("请大家留意"),s("strong",[t._v("同步通道和缓冲通道在声明时的区别，只在于是否定义缓冲区的大小。当缓冲区大小的值为 0 时，通道的类型将为同步通道。")])]),t._v(" "),s("p",[t._v("接下来只考虑产蛋的部分，即数据的发送端。假设这只鸡 7 天中每一天都会产下 1 个鸡蛋，且每天都将产下的鸡蛋拿到盛蛋的容器中。我们使用一个 for 循环结构来描述这个过程，将 layEggs() 函数修改如下：")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("go")]),t._v("\n复制代码"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("layEggs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("defer")]),t._v(" syncWait"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Done")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" DaysOfWeek"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\ttime"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Sleep")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("time"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Millisecond "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("500")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t\tintChan "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n         fmt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"产鸡蛋了"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("close")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("intChan"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("在每次 for 循环一开始，都延迟了 0.5 秒执行，表示 1 天。")]),t._v(" "),s("p",[t._v("接着再来考虑收集鸡蛋的过程，和产蛋类似，该过程每天都进行一次，因此也可使用 for 循环来描述，具体代码如下：")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("go")]),t._v("\n复制代码"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("collectEggs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("intChan "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("chan")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("defer")]),t._v(" syncWait"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Done")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" eggCounts "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" DaysOfWeek"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      eggCounts "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<-")]),t._v("intChan\n      fmt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"鸡蛋被收集了"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n   fmt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Printf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"本周共产%d个鸡蛋\\n"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" eggCounts"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("最后，保持 main() 函数不做修改，运行整个代码，可以观察到控制台如下输出：")]),t._v(" "),s("blockquote",[s("p",[t._v("产鸡蛋了")]),t._v(" "),s("p",[t._v("鸡蛋被收集了")]),t._v(" "),s("p",[t._v("产鸡蛋了")]),t._v(" "),s("p",[t._v("鸡蛋被收集了")]),t._v(" "),s("p",[t._v("产鸡蛋了")]),t._v(" "),s("p",[t._v("鸡蛋被收集了")]),t._v(" "),s("p",[t._v("产鸡蛋了")]),t._v(" "),s("p",[t._v("鸡蛋被收集了")]),t._v(" "),s("p",[t._v("产鸡蛋了")]),t._v(" "),s("p",[t._v("鸡蛋被收集了")]),t._v(" "),s("p",[t._v("产鸡蛋了")]),t._v(" "),s("p",[t._v("鸡蛋被收集了")]),t._v(" "),s("p",[t._v("产鸡蛋了")]),t._v(" "),s("p",[t._v("鸡蛋被收集了")]),t._v(" "),s("p",[t._v("本周共产7个鸡蛋")])]),t._v(" "),s("p",[t._v("显然，“产鸡蛋了”和“鸡蛋被收集了”成对出现 7 次。表示这只鸡每天会产 1 个鸡蛋，这颗鸡蛋也会被按天收取。最终程序输出了一周产蛋总数为 7 颗，程序运行结束。")]),t._v(" "),s("p",[t._v("在使用同步通道时，一个强制性的要求便是每次发送和接收都必须成对存在。反之，在使用缓冲通道时则没有如此强制性的要求。就拿上例来说，虽然这只鸡在 7 天内每天都会产鸡蛋，但如果将收集鸡蛋的工作安排在周一至周五，即 5 天，就需要将 connectEggs() 函数体中循环的终止条件改为 i<5 。如此修改后，程序依然会正常运行，产鸡蛋的工作同样会执行 7 次，但收鸡蛋的工作只会执行 5 次。具体控制台输出将如下所示：")]),t._v(" "),s("blockquote",[s("p",[t._v("产鸡蛋了")]),t._v(" "),s("p",[t._v("鸡蛋被收集了")]),t._v(" "),s("p",[t._v("产鸡蛋了")]),t._v(" "),s("p",[t._v("鸡蛋被收集了")]),t._v(" "),s("p",[t._v("产鸡蛋了")]),t._v(" "),s("p",[t._v("鸡蛋被收集了")]),t._v(" "),s("p",[t._v("产鸡蛋了")]),t._v(" "),s("p",[t._v("鸡蛋被收集了")]),t._v(" "),s("p",[t._v("产鸡蛋了")]),t._v(" "),s("p",[t._v("鸡蛋被收集了")]),t._v(" "),s("p",[t._v("本周共产5个鸡蛋")]),t._v(" "),s("p",[t._v("产鸡蛋了")]),t._v(" "),s("p",[t._v("产鸡蛋了")])]),t._v(" "),s("p",[t._v("可以看到，“产鸡蛋了”和“鸡蛋被收集了”成对出现 5 次。")]),t._v(" "),s("p",[t._v("如果更激进一些，从 main() 中去掉 collectEggs() 函数的调用，程序还能正常运行吗？")]),t._v(" "),s("p",[t._v("答案是："),s("strong",[t._v("肯定的")]),t._v("。试想一下，现实生活中的快递驿站并不会因某个人没取快递而关门，快递员也不会关心收件人是否取快递，只需将快递放到驿站就大功告成了。本例中的鸡产鸡蛋也是类似的道理，无论鸡蛋被怎样处理，它该下蛋还是会下蛋。")]),t._v(" "),s("h2",{attrs:{id:"构建安全的通道"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构建安全的通道"}},[t._v("#")]),t._v(" 构建安全的通道")]),t._v(" "),s("p",[t._v("在实际开发中，协程的使用可以说是非常普遍且复杂，多个协程之间的通信更是常见。由于协程各为异步运行的状态，这就要求开发者在使用通道时多加注意，以防造成不可预期的结果。")]),t._v(" "),s("p",[t._v("在接下来的内容中，我将为大家介绍两个重要的有助于增强通道健壮性的方法，即通道的关闭和单向通道的构建。")]),t._v(" "),s("h3",{attrs:{id:"通道的关闭"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#通道的关闭"}},[t._v("#")]),t._v(" 通道的关闭")]),t._v(" "),s("p",[t._v("不知道大家注意到没有，小册中有关通道的示例在发送数据后都会调用内置的 close() 函数关闭通道。实际上，在关闭通道方面也是有一些讲究的。")]),t._v(" "),s("p",[t._v("正如前面的示例那样，我们应该"),s("strong",[t._v("只让某个通道的唯一发送者关闭该通道")]),t._v("，这是关闭通道的原则之一。试想，如果多个发送者共用相同的通道，且都会在某种条件下关闭。那么一旦关闭了该通道，其它发送者就再也没有机会使用通道发送数据了。")]),t._v(" "),s("p",[t._v("从另一个角度讲，"),s("strong",[t._v("发送者最好使用各自的通道")]),t._v("。当然，如果非要多个发送者共用一个通道，"),s("strong",[t._v("可以通过恢复机制来规避程序宕机")]),t._v("。但这样做是不推荐的，因为它违反了关闭通道的原则。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("❗️ 注意：通道关闭后，无法再通过它发送数据，但不会影响数据的接收。\n")])])]),s("p",[t._v("除此之外，关闭通道还有一个原则是"),s("strong",[t._v("不允许关闭一个已经关闭了的通道")]),t._v("。否则也会引发程序宕机，错误信息为：panic: close of closed channel。由此便引出一个问题：如何判断通道已经关闭了呢？")]),t._v(" "),s("p",[t._v("我们可以通过"),s("strong",[t._v("尝试从通道中接收值来判断通道是否关闭")]),t._v("。我们将本讲示例代码中的 collectEggs() 函数稍加修改如下：")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("go")]),t._v("\n复制代码"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("collectEggs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("intChan "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("chan")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("defer")]),t._v(" syncWait"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Done")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" eggCounts "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" DaysOfWeek"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      eggCounts "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<-")]),t._v("intChan\n      fmt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"鸡蛋被收集了"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("_")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" isOpen "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<-")]),t._v("intChan\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("isOpen "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      fmt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Printf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"本周共产%d个鸡蛋\\n"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" eggCounts"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("请各位留意最后 5 行代码。尝试从通道接收值时，除了可以得到值本身外，还可得到一个布尔类型的值。当这个布尔类型的值为 true 时，通道打开；反之，则表示通道已经被关闭了。")]),t._v(" "),s("p",[t._v("如上修改后，控制台输出结果不变。")]),t._v(" "),s("p",[t._v("另外，使用 for-range 循环结构可简化上述代码。当通道关闭后，for-range 循环会自动跳出。下面的代码与上面的代码具有同样的运行结果。")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("go")]),t._v("\n复制代码"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("collectEggs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("intChan "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("chan")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("defer")]),t._v(" syncWait"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Done")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" eggCounts "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" intValue "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("range")]),t._v(" intChan "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      eggCounts "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" intValue\n      fmt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"鸡蛋被收集了"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n   fmt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Printf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"本周共产%d个鸡蛋\\n"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" eggCounts"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"单向通道的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单向通道的使用"}},[t._v("#")]),t._v(" 单向通道的使用")]),t._v(" "),s("p",[t._v("本讲的最后，我们来聊聊单向通道的构建。")]),t._v(" "),s("p",[t._v("在实际项目中，有时候需要"),s("strong",[t._v("特别规定数据的流向，以确保其正确性")]),t._v("。这有点类似于单行道和双向车道，前者只能按照规定的方向行驶，后者来去都是自由的。")]),t._v(" "),s("p",[t._v("本讲案例中， layEggs() 和 collectEggs() 都使用了 intChan 通道。但很明显，前者只负责数据的发送，后者只负责数据的接收。像这种情况，我们就可以基于 intChan ，构建只能发送的通道，用于 layEggs() 函数；构建只能接收的通道，用于 collectEggs() 函数。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("💡 提示：单向通道不是凭空声明的，它需要基于已有的通道。\n")])])]),s("p",[t._v("结合本例，下面的代码基于已有的 intChan 创建了名为 readOnlyIntChan 的只接收通道：")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("go")]),t._v("\n复制代码"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" readOnlyIntChan "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<-")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("chan")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" intChan\n")])])]),s("p",[t._v("这句代码中， <-chan 表示只接收通道。与其相反， chan<- 则表示只发送通道。下面的代码基于已有的 intChan 创建了名为 sendOnlyIntChan 的只发送通道：")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("go")]),t._v("\n复制代码"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" sendOnlyIntChan "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("chan")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" intChan\n")])])]),s("h2",{attrs:{id:"小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),s("p",[t._v("🎉 恭喜，您完成了本次课程的学习！")]),t._v(" "),s("p",[t._v("📌 以下是本次课程的重点内容总结：")]),t._v(" "),s("ol",[s("li",[t._v("缓冲通道的使用；")]),t._v(" "),s("li",[t._v("构建安全的通道；\n"),s("ul",[s("li",[t._v("通道的关闭；")]),t._v(" "),s("li",[t._v("单向通道的构建。")])])])]),t._v(" "),s("p",[t._v("本讲继续上一讲的话题：通道（Channel）。首先介绍的就是缓冲通道的使用，示例还是鸡生蛋。不过这次加了缓冲区，即存放鸡蛋的容器。鸡产蛋后，先将鸡蛋放入缓冲区中，等待人来统计。缓冲区的大小被预先定义，超过缓冲区大小的数据无法放入其中。另外，即使没有数据的接收方，发送方也可以将数据放入缓冲区中，不影响其正常运行。这一点是与同步通道最大的区别。")]),t._v(" "),s("p",[t._v("另外，为了增强程序的健壮性，本讲介绍了关闭通道时的两个重要原则：即"),s("strong",[t._v("只让某个通道的唯一发送者关闭该通道")]),t._v("、"),s("strong",[t._v("不允许关闭一个已经关闭了的通道")]),t._v("。由这两个原则引申出的两个知识点是："),s("strong",[t._v("发送者最好使用各自的通道")]),t._v("以及从"),s("strong",[t._v("通道中接收值来判断通道是否关闭")]),t._v("。")]),t._v(" "),s("p",[t._v("最后，为了确保数据的正确流向，本讲还介绍了"),s("strong",[t._v("单向通道的构建")]),t._v("。值得一提的是，"),s("strong",[t._v("构建单向通道必须以某个已经存在的通道为基础")]),t._v("。强制向只接收的单向通道中发送数据将导致程序运行出错，反之亦然。")]),t._v(" "),s("p",[t._v("➡️ 在下次课程中，我们会继续介绍 Go 语言中的并发，具体内容如下：")]),t._v(" "),s("ol",[s("li",[t._v("并发中的 Select 结构")]),t._v(" "),s("li",[t._v("Go 语言中的定时器\n"),s("ul",[s("li",[t._v("Timer")]),t._v(" "),s("li",[t._v("Ticker")])])])])])}),[],!1,null,null,null);s.default=e.exports}}]);